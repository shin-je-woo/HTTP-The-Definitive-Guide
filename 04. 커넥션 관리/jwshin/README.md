# 04. 커넥션 관리

## 4.1 TCP 커넥션

- 전 세계 모든 HTTP 통신은 TCP/IP를 통해 이루어진다.
- TCP 커넥션이 맺어지면 클라이언트와 서버 간에 주고받는 메시지들은 손실, 손상되거나 순서가 바뀌지 않고 안전하게 전달된다.
    
    <img width="643" height="556" alt="image" src="https://github.com/user-attachments/assets/c04d041f-3da8-444c-aa4d-f0cde04bc780" />
    

### 4.1.1 신뢰할 수 있는 데이터 전송 통로인 TCP

- HTTP 커넥션은 대부분 TCP 커넥션 위에서 동작한다.
- TCP 커넥션이 제공하는 보장
    - 데이터 손실 방지
    - 순서 보장
    - 중복 데이터 제거
- 따라서 HTTP 애플리케이션은 패킷 손실, 재전송, 순서 재조정 같은 문제를 직접 처리하지 않는다.

### 4.1.2 TCP 스트림은 세그먼트로 나뉘어 IP 패킷을 통해 전송된다

- TCP는 데이터 스트림을 세그먼트 단위로 나누고, IP 패킷에 담아서 전송한다.
- HTTP가 메시지를 전송하고자 할 경우, 현재 연결되어 있는 TCP 커넥션을 통해서 데이터의 내용을 순서대로 보낸다.
- TCP/IP 계층은 HTTP 아래에서 완전히 추상화된다.
    
    <img width="620" height="283" alt="image" src="https://github.com/user-attachments/assets/6bf568e9-eae8-4b56-b889-be2a0c1bc3ff" />
    
    <img width="630" height="612" alt="image" src="https://github.com/user-attachments/assets/335407c6-14f1-4b38-b817-039da3b8c029" />
    

### 4.1.3 TCP 커넥션 유지하기

- 한 컴퓨터는 동시에 여러 TCP 커넥션을 가질 수 있다. TCP는 포트 번호를 통해서 여러 개의 커넥션을 유지한다.
- TCP 커넥션은 다음 네 가지 값으로 식별된다.
    - 발신지 IP 주소
    - 발신지 포트
    - 목적지 IP 주소
    - 목적지 포트
- 이 네 값이 모두 같아야 동일한 TCP 커넥션이다.

### 4.1.4 TCP 소켓 프로그래밍

- 운영체제는 TCP 커넥션을 제어하기 위한 소켓 API를 제공한다.
- 소켓 API는 TCP 연결을 만들고, 원격 서버와 데이터를 읽고 쓸 수 있게 해준다.
- TCP API는 연결 설정을 위한 핸드셰이킹과 데이터 분할, 재조립 같은 네트워크 처리 과정을 내부에서 모두 처리한다.
    
    <img width="612" height="403" alt="image" src="https://github.com/user-attachments/assets/d43190c7-9772-4998-ac91-3b36cc3b3f02" />
    
    <img width="628" height="434" alt="image" src="https://github.com/user-attachments/assets/8cbbd79a-d7d6-4d78-a374-8f2079fddf06" />
    

## 4.2 TCP의 성능에 대한 고려

- HTTP 성능은 TCP 성능에 직접적인 영향을 받는다.
- HTTP 트랜잭션 지연의 대부분은 애플리케이션 처리 시간이 아니라 TCP 네트워크 지연에서 발생한다.

### 4.2.1 HTTP 트랜잭션 지연

- HTTP 트랜잭션 처리 단계
    - DNS 조회
    - TCP 커넥션 설정
    - HTTP 요청 전송
    - 서버 처리
    - HTTP 응답 전송
- 이 중 서버 처리 시간이 크지 않다면 대부분의 지연은 네트워크와 TCP에서 발생한다.
    
    <img width="622" height="266" alt="image" src="https://github.com/user-attachments/assets/187bd209-c692-43bf-abb8-153e176c40cd" />
    

### 4.2.2 성능 관련 중요 요소

HTTP 성능에 영향을 주는 대표적인 TCP 요소

- TCP 커넥션 핸드셰이크 지연
- TCP 느린 시작 slow start
- 네이글 알고리즘
- 확인응답 지연 알고리즘
- TIME_WAIT 지연과 포트 고갈

### 4.2.3 TCP 커넥션 핸드셰이크 지연

- 새로운 TCP 커넥션을 만들 때 반드시 3단계 핸드셰이크가 필요하다.
    - SYN 플래그
    - SYN ACK 플래그
    - ACK 플래그
- 작은 HTTP 트랜잭션의 경우 전체 시간의 상당 부분이 이 핸드셰이크에 소비된다.
    
    <img width="629" height="272" alt="image" src="https://github.com/user-attachments/assets/8cf1a8df-a9ec-494f-9002-10e0ba0caacb" />
    

### 4.2.4 확인응답 지연

- 인터넷은 패킷 전송을 완벽히 보장하지 않기 때문에 TCP는 신뢰성을 위해 확인응답(ACK)을 사용한다.
- ACK는 단독으로 전송될 수도 있고, 반대 방향으로 보낼 데이터가 있을 경우 데이터 세그먼트에 함께 실어(편승) 보낼 수도 있다.
- ACK-only 패킷이 자주 발생하면 오버헤드가 커질 수 있으므로, TCP는 ACK 전송 횟수를 줄이기 위해 확인응답 지연(Delayed ACK)을 사용한다.
- 확인응답 지연은 ACK를 즉시 보내지 않고 잠시 대기하여 추가로 도착한 데이터에 대한 ACK를 합치거나, 송신할 데이터가 생기면 ACK를 데이터에 편승시켜 전송함으로써 네트워크 효율을 높인다.
- 단, 지연 ACK는 지연 시간을 늘릴 수 있으며, Nagle 알고리즘과 함께 동작할 때 지연이 커지는 경우가 있다.

### 4.2.5 TCP 느린 시작 (slow start)

- TCP는 커넥션을 시작할 때 혼잡 윈도우(cwnd)를 작게 설정해 한 번에 전송할 수 있는 데이터량을 제한한다.
- 이후 ACK를 통해 데이터가 정상적으로 전달됨을 확인하면서 cwnd를 빠르게(대략 RTT마다 2배로) 증가시켜 전송량을 늘린다.
- 이 초기 단계의 전송량 증가 과정을 느린 시작(slow start)이라 하며, 네트워크의 급격한 혼잡을 방지하면서 가용 대역폭을 탐색한다.
- cwnd가 임계값(ssthresh)에 도달하면 보통 혼잡 회피 단계로 전환되어 전송량을 더 완만하게 증가시킨다.
- 따라서 충분히 전송을 수행해 cwnd가 커진 연결에 비해, 새 연결은 초반 처리량이 낮아 상대적으로 느릴 수 있다.

### 4.2.6 네이글 알고리즘과 TCP_NODELAY

- 작은 데이터를 write 할 때마다 즉시 전송하면 작은 TCP 세그먼트가 다량 발생해 네트워크 및 CPU 오버헤드가 증가할 수 있다.
- 네이글 알고리즘(Nagle Algorithm)은 이러한 작은 패킷 난사를 줄이기 위해, **아직 ACK를 받지 못한 작은 세그먼트가 존재하는 동안** 새로 발생한 작은 데이터를 즉시 보내지 않고 버퍼링한다.
- 이후 **ACK가 도착하거나**, 버퍼에 쌓인 데이터가 충분히 커져(MSS에 근접) 한 번에 보낼 수 있을 때 전송하여 패킷 수를 줄인다.
- 단, 작은 메시지가 빈번한 요청-응답(예: 짧은 RPC, 인터랙티브 트래픽)에서는 ACK를 기다리는 동작이 지연을 유발할 수 있으며, 수신 측의 Delayed ACK와 함께 동작할 경우 지연이 커지는 경우가 있다.
- TCP_NODELAY는 네이글 알고리즘을 비활성화하는 소켓 옵션으로, 지연 민감한 트래픽에서 유리할 수 있으나 작은 패킷이 증가할 수 있으므로 트레이드오프를 고려해 적용한다.

### 4.2.7 TIME_WAIT의 누적과 포트 고갈

- TCP 연결이 정상 종료되면, 종료를 주도한 쪽(대개 active close)이 일정 시간 TIME_WAIT 상태로 남는다.
- TIME_WAIT은 다음을 보장하기 위한 안전장치이다.
    - 지연된 세그먼트가 다음 연결에 섞이는 것을 방지한다.
    - 마지막 ACK 유실 시 상대의 FIN 재전송에 대응해 연결 종료를 확실히 마무리한다.
- TIME_WAIT 동안에는 동일한 4-튜플(src ip, src port, dst ip, dst port)을 즉시 재사용하기 어렵고, 특히 클라이언트(outbound)에서 목적지(dst ip:dst port)가 고정이면 src port가 빠르게 소모될 수 있다.
- 짧은 연결을 대량으로 생성하면 TIME_WAIT이 누적되어 임시 포트(ephemeral port) 풀이 고갈될 수 있다.
    - 대략적인 위험도는 `초당 새 연결 수(CPS) × TIME_WAIT 시간(초)`로 가늠할 수 있으며, 이 값이 사용 가능한 임시 포트 수보다 커지면 신규 연결 실패/지연이 발생하기 쉽다.
- 포트 고갈이 발생하면 connect 실패, 타임아웃, 재시도 폭증으로 인해 지연이 급격히 증가할 수 있다.
- 성능 테스트 환경에서는 keep-alive/커넥션 풀 없이 요청당 새 연결 패턴으로 높은 QPS를 만들기 쉬워 TIME_WAIT 누적과 포트 고갈 문제가 특히 잘 드러난다.
- 완화 방법은 보통 다음 순서로 고려한다.
    - HTTP keep-alive 및 커넥션 풀링으로 연결 재사용
    - 임시 포트 범위 확장 및 출발지 IP(노드) 수평 확장
    - TIME_WAIT 관련 튜닝은 부작용이 있을 수 있어 마지막에 신중히 적용

## **4.3 HTTP 커넥션 관리**

- 앞 절에서는 TCP 커넥션과 TCP 성능 특성이 HTTP 성능에 미치는 영향을 다루었다.
- 이제부터는 **HTTP 계층에서 커넥션을 어떻게 생성하고 재사용하며 최적화하는지**를 다룬다.
- 특히 HTTP 커넥션 관리에서 **자주 오해되는 헤더와 잘못된 사용 방식을 다룬다.**

### **4.3.1 흔히 잘못 이해하는 Connection 헤더**

- HTTP는 클라이언트와 서버 사이에 프락시 서버, 캐시 서버 같은 **중개 서버가 개입하는 구조**를 허용한다.
- 하나의 HTTP 메시지는 여러 중개 서버를 거쳐 전달될 수 있다.
- 이 구조 때문에 모든 헤더가 모든 커넥션에 그대로 전달되면 안 되는 경우가 발생한다.
- Connection 헤더에 포함될 수 있는 값은 다음과 같은 의미를 가진다.
    - HTTP 헤더 필드 이름: 현재 커넥션에서만 유효한 헤더 목록
    - 임시적인 토큰 값: 커넥션 단위 옵션
    - close: 현재 요청 처리가 끝나면 커넥션을 종료해야 함을 의미
        
        <img width="623" height="254" alt="image" src="https://github.com/user-attachments/assets/5c009ce1-3659-4e56-8391-50007777a4f0" />
        
- Connection 헤더에 명시된 헤더들은 현재 커넥션에서만 유효하며 다음 홉으로 전달되기 전에 반드시 제거되어야 한다. 이런 헤더를 **hop-by-hop 헤더**라고 부른다.
- 수신자는 Connection 헤더에 나열된 옵션을 적용한 뒤 메시지를 다음 홉으로 전달하기 전에 Connection 헤더에 명시된 모든 헤더 를 제거해야 한다.
- 대표적인 hop-by-hop 헤더 (Connection헤더에 기술되어 있지 않아도 홉별 헤더이다.)
    - Proxy Authenticate
    - Proxy Connection
    - Transfer Encoding
    - Upgrade

### **4.3.2 순차적인 트랜잭션 처리에 의한 지연**

- 커넥션 관리가 제대로 되지 않으면 TCP 성능 자체보다 더 큰 지연이 발생할 수 있다.
- 예를 들어 하나의 HTML 문서와 여러 개의 이미지가 있는 웹 페이지를 로드할 경우 브라우저가 리소스를 순차적으로 요청하면 각 요청마다 커넥션 생성 및 TCP 느린 시작이 반복된다.
    
    <img width="613" height="256" alt="image" src="https://github.com/user-attachments/assets/bac6d091-d25c-485b-89d8-26052230acae" />
    
- 순차 처리 방식은 HTML을 먼저 내려받고 이미지들을 하나씩 차례로 요청해서 매 요청마다 커넥션 지연과 초기화 비용이 발생한다.
- 이 지연은 네트워크 전송 시간이 아니라 커넥션 설정과 대기 시간에서 주로 발생한다.
- 사용자 입장에서는 전체 다운로드 시간이 크게 차이나지 않더라도 화면이 오랫동안 비어 있거나 일부만 표시되면 훨씬 느리게 느껴진다.

## **4.4 병렬 커넥션**

- 순차 처리의 지연을 줄이기 위한 방법 중 하나가 병렬 커넥션이다.
- 병렬 커넥션은 클라이언트가 여러 개의 TCP 커넥션을 동시에 생성하고 여러 HTTP 요청을 병렬로 처리하는 방식이다.

### **4.4.1 병렬 커넥션은 페이지를 더 빠르게 내려받는다**

- 여러 커넥션을 동시에 사용하면 각 커넥션의 대기 시간이 겹쳐져서 결과적으로 전체 지연 시간이 감소한다.
- 이미지가 많은 페이지에서 특히 효과가 크다.
    
    <img width="632" height="314" alt="image" src="https://github.com/user-attachments/assets/91ca9a5e-3fef-495b-b067-26dd25d21980" />
    

### **4.4.2 병렬 커넥션이 항상 더 빠르지는 않다**

- 병렬 커넥션에는 한계가 있다.
- 클라이언트의 네트워크 대역폭은 제한되어 있고, 커넥션 수가 늘어나면 각 커넥션이 사용할 수 있는 대역폭은 줄어든다.
- 저속 네트워크 환경에서는 여러 커넥션이 서로 대역폭을 나눠 쓰게 되어 오히려 성능이 나빠질 수 있다.
- 서버 입장에서도 과도한 병렬 커넥션은 리소스 소모 증가와 부하 증가로 이어질 수 있다.

### **4.4.3 병렬 커넥션은 더 빠르게 느껴질 수 있다**

- 병렬 커넥션의 중요한 효과는 체감 성능 개선이다.
- 실제 전체 다운로드 시간이 더 걸리더라도 화면에 여러 요소가 동시에 표시되면 사용자는 더 빠르다고 느낀다.
- 사용자는 페이지 전체 완료 시간보다 화면에서 변화가 일어나는 속도에 더 민감하다.

## **4.5 지속 커넥션**

- 웹 클라이언트는 보통 하나의 웹 페이지를 가져오기 위해 같은 서버에 여러 번 요청을 보낸다.
- 매 요청마다 TCP 커넥션을 새로 생성하고 종료하는 방식은 다음과 같은 비용을 유발한다.
    - TCP 3-way handshake 지연
    - TCP slow start로 인한 전송 속도 저하
    - 커넥션 생성과 종료에 따른 서버 자원 소모
- 이러한 문제를 줄이기 위해 하나의 TCP 커넥션을 여러 HTTP 트랜잭션에 재사용하는 방식이 지속 커넥션이다.

### **4.5.1 지속 커넥션 vs 병렬 커넥션**

- 병렬 커넥션은 여러 개의 TCP 커넥션을 동시에 열어 여러 객체를 동시에 내려받는다.
- 병렬 커넥션에는 명확한 단점이 있다.
    - 각 트랜잭션마다 새로운 TCP 커넥션을 맺고 끊어야 한다.
    - 매 커넥션마다 TCP slow start가 다시 발생한다.
    - 브라우저와 서버 모두 동시에 열 수 있는 커넥션 수에 제한이 있다.
- 지속 커넥션은 다음과 같은 장점을 가진다.
    - TCP handshake 비용을 줄인다.
    - 이미 튜닝된 TCP 커넥션을 재사용할 수 있다.
    - 전체 커넥션 수를 줄여 서버 부하를 완화한다.
- 단, 지속 커넥션을 잘못 관리하면 오래 열린 유휴 커넥션이 쌓여 서버 자원을 소모할 수 있다.
- 따라서 실제로는 병렬 커넥션과 지속 커넥션을 함께 사용하는 전략이 가장 효과적이다.

### **4.5.2 HTTP/1.0+의 Keep-Alive 커넥션**

- HTTP/1.0은 기본적으로 비지속 커넥션이다.
- 그러나 성능 문제로 인해 일부 클라이언트와 서버는 확장 기능 형태의 keep-alive 커넥션을 도입했다.
- HTTP/1.0 keep-alive의 특징
    - 표준이 아닌 확장 기능이다.
    - 클라이언트는 요청에 Connection: Keep-Alive 헤더를 포함해 커넥션 유지를 요청한다.
    - 서버가 이를 지원하면 응답에도 같은 헤더를 포함한다.
- keep-alive 커넥션의 효과
    - 여러 HTTP 트랜잭션을 하나의 TCP 커넥션으로 처리할 수 있다.
    - 커넥션 생성과 종료에 따른 지연이 제거된다.
- 하지만 HTTP/1.0 keep-alive는 설계상 여러 문제를 안고 있었다.
    - 모든 구성 요소가 이를 정확히 이해하지 못한다.
    - 특히 프록시가 개입될 경우 문제가 쉽게 발생한다.
- 이러한 문제들은 HTTP/1.1에서 구조적으로 개선된다.

### **4.5.3 Keep-Alive 동작**

- HTTP/1.0 keep-alive를 사용하는 경우의 기본 흐름은 다음과 같다.
    - 클라이언트가 요청에 Connection: Keep-Alive 헤더를 포함한다.
    - 서버가 이를 수용하면 응답에도 같은 헤더를 포함한다.
    - 이후 동일한 TCP 커넥션으로 추가 요청과 응답이 오간다.
- 응답에 Connection: Keep-Alive 헤더가 없다면 클라이언트는 서버가 커넥션을 끊을 것으로 추정한다.
- 이 방식은 양쪽 모두가 명시적으로 keep-alive를 이해하고 있어야만 정상 동작한다.
    
    <img width="620" height="330" alt="image" src="https://github.com/user-attachments/assets/cfb2a69c-096a-4916-bc6f-c3942b00722a" />
    

### **4.5.4 Keep-Alive 옵션**

- Keep-Alive 헤더에는 추가적인 제어 옵션이 포함될 수 있다.
- timeout 옵션
    - Keep-Alive 응답 헤더를 통해 보낸다.
    - 커넥션을 얼마 동안 유지할 것인지를 나타낸다.
    - 단, 실제로 이 시간이 보장되지는 않는다.
- max 옵션
    - Keep-Alive 응답 헤더를 통해 보낸다.
    - 해당 커넥션으로 처리할 수 있는 HTTP 트랜잭션의 최대 개수
- keep-alive 옵션은 요청이 아니라 힌트에 가깝다. 서버는 언제든 커넥션을 끊을 수 있다.
- 따라서 클라이언트는 커넥션이 언제 끊어질지 모른다는 전제하에 재시도 가능하도록 구현되어야 한다.
    
    <img width="239" height="66" alt="image" src="https://github.com/user-attachments/assets/c14631a3-7a0e-4bae-90c3-acb5eb729ed5" />
    

### **4.5.5 Keep-Alive 커넥션 제한과 규칙**

- keep-alive 커넥션을 사용할 때 지켜야 할 중요한 규칙들이 있다.
- 커넥션을 계속 유지하려면 모든 메시지에 Connection: Keep-Alive 헤더를 포함해야 한다.
- 커넥션을 유지하는 동안 모든 메시지의 길이를 정확히 알아야 한다.
- 길이를 알 수 없는 응답이 오면 커넥션의 끝과 메시지의 끝을 구분할 수 없기 때문에 커넥션을 재사용할 수 없다.
- 프록시와 게이트웨이는 Connection 헤더에 명시된 모든 헤더를 반드시 제거해야 한다. 즉, hop-by-hop 헤더는 다음 서버로 전달되면 안 된다.

### **4.5.6 Keep-Alive와 멍청한(dumb) 프록시 문제**

- 멍청한 프록시는 keep-alive를 이해하지 못하는 프록시를 의미한다.
- 이런 프록시는 Connection 헤더를 단순 확장 헤더로 오해하고 그대로 다음 서버로 전달한다.
- 그 결과 발생하는 문제
    - 서버는 커넥션 유지 요청으로 오해한다.
    - 실제로는 프록시가 커넥션을 유지하지 않는다.
    - 클라이언트는 응답을 기다리다 멈춘다.
- 이는 HTTP/1.0 keep-alive의 가장 치명적인 문제 중 하나다.
- 이런 이유로 프록시는 Connection 헤더와 Connection 헤더에 명시된 헤더들은 절대 전달하면 안된다. 즉, Connection: Keep-Alive 헤더를 받으면 Connection 헤더, Keep-Alive 헤더 모두 전달하면 안 된다.
    
    <img width="623" height="416" alt="image" src="https://github.com/user-attachments/assets/1752fe1e-ad0c-4c00-918d-1e2c880a62e6" />
    

### **4.5.7 Proxy-Connection 헤더 살펴보기**

- 일부 브라우저는 이 문제를 해결하기 위해 Proxy-Connection 헤더를 도입했다.
- 하지만 이 방식은 모든 프록시 환경에서 일관되게 동작하지 않는다. 여러 단계의 프록시가 있는 경우 다시 문제가 발생할 수 있다.
- 결과적으로 근본적인 해결책은 아니다.
    
    <img width="623" height="534" alt="image" src="https://github.com/user-attachments/assets/9359f262-510a-43cc-8c63-8ff7703c146c" />
    

### **4.5.8 HTTP/1.1의 지속 커넥션**

- HTTP/1.1에서는 지속 커넥션이 기본 동작이다.
- 별도의 Keep-Alive 헤더 없이도 커넥션은 유지된다.
- 커넥션을 끊고 싶을 때만 Connection: close 헤더를 명시한다.

### **4.5.9 지속 커넥션의 제한과 규칙**

- HTTP/1.1에서도 다음 사항은 반드시 고려해야 한다.
- 클라이언트가 추가 요청을 보내지 않을 것이라면 마지막 요청에 Connection: close를 보내야 한다.
- 커넥션에 있는 모든 메시지가 길이 정보를 정확히 가지고 있을 때에만 커넥션을 지속할 수 있다. 예를 들어 엔터티 본문은 정확한 Content-Length 값을 가지거나 청크 전송 인코딩(chunked transfer encoding)으로 인코드 되어 있어야 한다.
- 프록시는 클라이언트와 서버 각각에 대해 별도의 지속 커넥션을 관리해야 한다.
- HTTP/1.1 애플리케이션은 중간에 끊어지는 커넥션을 복구할 수 있어야만 한다. 클라이언트는 다시 보내도 문제가 없는 요청이라면 가능한 한 다시 보내야 한다.
- 서버는 과부하를 방지하기 위해 동시에 유지 가능한 커넥션 수를 제한할 수 있다.

## **4.6 파이프라인 커넥션**

- HTTP/1.1은 **지속 커넥션을 기반으로 요청을 파이프라이닝**할 수 있다.
- 파이프라이닝은 여러 요청을 응답을 기다리지 않고 연속해서 전송하는 방식이다.
- 첫 번째 요청이 네트워크를 통해 전달되는 동안 두 번째 세 번째 요청도 연속해서 서버로 보낼 수 있다.
- 네트워크 왕복 시간이 긴 환경에서 특히 효과적이며, 전송 대기 시간(latency)을 줄여 성능을 개선한다.

### **파이프라이닝의 제약 사항**

- HTTP 클라이언트는 커넥션이 지속 커넥션임을 확신하기 전까지 파이프라인을 사용하면 안 된다.
- HTTP/1.1 파이프라이닝에서는 응답에 요청을 식별하는 ID가 없으므로, 클라이언트는 요청-응답을 순서로만 매칭한다. 따라서 서버는 응답을 요청 순서대로 보내야 한다.
- 커넥션이 언제 끊어질지 알 수 없으므로 파이프라인에 남아 있는 요청이 있다면 클라이언트는 언제든 다시 요청을 재전송할 준비가 되어 있어야 한다.
- 서버는 일부 요청만 처리한 뒤 커넥션을 끊을 수 있다.
    - 이 경우 처리되지 않은 요청은 실패하게 된다.
- 비멱등(non-idempotent) 요청은 파이프라인으로 보내면 안 된다.
    - 예: POST
    - 에러 발생 시 서버에서 어디까지 처리되었는지 알 수 없어서 재전송 시 중복 처리 위험이 발생한다.
        
        <img width="628" height="733" alt="image" src="https://github.com/user-attachments/assets/d783a394-4a47-476e-b96b-5cbe6d5fef23" />
        

## **4.7 커넥션 끊기에 대한 미스터리**

- HTTP에는 언제, 어떻게 커넥션을 끊어야 하는지에 대한 명확한 규칙이 없다.
- 이 문제는 문서로 정리된 것보다 훨씬 미묘하고 많은 구현이 경험과 관행에 의존한다.

### **4.7.1 마음대로 커넥션 끊기**

- HTTP 클라이언트, 서버, 프록시는 언제든 TCP 커넥션을 끊을 수 있다.
- 일반적으로 메시지를 모두 전송한 뒤 끊지만 에러 상황에서는 메시지 중간이나 엉뚱한 시점에 끊길 수도 있다.
- 서버가 유휴 커넥션이라고 판단해 끊었지만 클라이언트는 요청을 전송 중일 수 있다.
- 이 경우 클라이언트는 요청 전송 도중 에러를 맞게 된다.

### **4.7.2 Content-Length와 Truncation**

- 모든 HTTP 응답은 정확한 Content-Length 헤더를 가져야 한다.
- 오래된 서버 중 일부는 커넥션 종료를 데이터 전송 완료의 의미로 사용했다. 이로 인해 Content-Length가 없거나 잘못된 응답이 존재한다.
- 수신자는 실제 수신한 엔티티 길이와 Content-Length가 다르거나 Content-Length가 아예 없으면 데이터 길이를 정확히 알 수 없다.
- 캐시 프록시는 이런 응답을 캐시하면 안 된다. 잘못된 길이 정보는 치명적인 캐시 오류를 유발한다.
- 프록시는 Content-Length를 수정하려 해서는 안 되고 받은 메시지를 그대로 전달해야 한다.

### **4.7.3 커넥션 끊기의 허용, 재시도, 멱등성**

- 커넥션은 에러가 없어도 언제든 끊길 수 있다.
- HTTP 애플리케이션은 커넥션이 예기치 않게 끊겼을 때 어떤 요청은 재시도해도 안전하고 어떤 요청은 위험한지 구분할 수 있어야 한다.
- 비멱등 요청은 어디까지 서버가 처리했는지 알 수 없으므로 특히 위험하다.
- 대부분의 브라우저는 POST 요청을 자동으로 재시도하지 않고 사용자에게 재전송 여부를 묻는다.

### **4.7.4 우아한 커넥션 끊기**

- TCP 커넥션은 양방향(full-duplex)이다.
- 각 방향에는 입력 큐 출력 큐가 존재한다.
- 애플리케이션은 전체 끊기, 입력만 끊기, 출력만 끊기 중 하나를 선택할 수 있다.
    
    <img width="616" height="416" alt="image" src="https://github.com/user-attachments/assets/a6c30a80-ac16-49fb-9988-782916b50f6b" />
    
- 우아한 커넥션 끊기의 기본 원칙
    - 자신의 출력 채널을 먼저 닫는다.
    - 상대방이 더 이상 데이터를 보내지 않을 것임을 인지하게 한다.
- 입력 채널을 먼저 닫으면 상대방이 아직 데이터를 보내고 있을 수 있기 때문에 위험하다.
- 잘못된 절반 끊기는 TCP reset by peer 에러를 유발할 수 있다. (입력 채널 절반 끊기)
