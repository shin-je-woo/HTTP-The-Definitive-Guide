# 01. HTTP 개관

> 💡 **HTML**은 *HyperText Markup Language*의 약자로, 태그를 사용하여 문서의 구조와 의미를 표현하는 언어이다.
> - **HyperText**란 문서 안에서 다른 문서로 이동할 수 있는 링크가 포함된 텍스트를 말한다.

- **HTTP**(*HyperText Transfer Protocol*)는 하이퍼텍스트 전송 규약이다.
- 초기에는 HTML 문서 공유 목적으로 만들어졌다.
- 현재는 이미지, 동영상, 파일, JSON 등 거의 모든 웹 리소스를 전달하는 표준이다.

---

## 1.1 HTTP: 인터넷의 멀티미디어 배달부

- 웹에서 데이터를 주고받는 대표적인 프로토콜이다.
- 이미지, HTML 페이지, 동영상, 오디오 파일 등 다양한 멀티미디어 콘텐츠를 운반한다.
- 빠르고 간단하며 신뢰할 수 있는 전송을 지향한다.

> 💡 HTTP는 **TCP 기반**의 신뢰성 있는 데이터 전송 프로토콜을 사용하므로, 데이터 손실 걱정 없이 애플리케이션 기능 구현에 집중할 수 있다.

---

## 1.2 웹 클라이언트와 서버
<img width="500" height="150" alt="img_1" src="https://github.com/user-attachments/assets/cc35b831-a06c-4576-8ead-ecf498d481e9" />

- **클라이언트**: 리소스를 요청하는 쪽 (브라우저, 모바일 앱 등)
- **서버**: 요청에 응답하여 리소스를 제공하는 쪽
- 클라이언트가 HTTP 요청을 보내면 서버가 HTTP 응답을 돌려주는 구조다.
- 이 둘이 웹의 가장 기본적인 구성 요소다.

---

## 1.3 리소스

- 웹에서 제공하는 모든 콘텐츠를 통칭한다.
- HTML 문서, 이미지, 동영상뿐 아니라 동적으로 생성되는 데이터까지 포함된다.
- 서버는 이런 리소스들을 관리하고 요청이 오면 제공한다.

### 1.3.1 미디어 타입

- HTTP는 전송하는 데이터 형식을 MIME 타입으로 표기한다.
- 주 타입과 부 타입으로 나뉜다 (예: `text/html`, `image/jpeg`).
- 클라이언트는 이 타입을 보고 데이터를 어떻게 처리할지 결정한다.

### 1.3.2 URI

- *Uniform Resource Identifier*의 줄임말이다.
- 리소스를 유일하게 식별하기 위한 통합 체계다.
- URL과 URN을 포괄하는 상위 개념이다.

### 1.3.3 URL

- *Uniform Resource Locator*의 줄임말이다.
- 리소스의 위치와 접근 방법을 함께 명시한다.
- 스킴, 호스트, 경로로 구성된다.
- 실무에서 URI라고 부르는 것은 대부분 URL을 가리킨다.

예: `http://www.oreilly.com/index.html`
- `http` → 스킴
- `www.oreilly.com` → 호스트
- `/index.html` → 경로

### 1.3.4 URN

- *Uniform Resource Name*의 줄임말이다.
- 위치와 상관없이 리소스를 식별하는 이름이다.
- 예: `urn:isbn:0-486-27577-4`
- 아이디어는 좋지만 실제로 널리 쓰이지는 않는다.

> 💡 **URL vs URN 정리**
> - URL: 리소스를 **어떻게 얻고 어디에 있는지** 명시
> - URN: 위치 없이 **리소스 자체를 특정**하는 것이 목표

---

## 1.4 트랜잭션

- HTTP 트랜잭션은 요청 한 번과 응답 한 번으로 이루어진다.
- 하나의 웹페이지를 보여주기 위해 여러 트랜잭션이 연속으로 발생하기도 한다.

### 1.4.1 메서드

- 서버에 어떤 동작을 요청할지 나타낸다.
- 주요 메서드: GET(조회), POST(생성/처리), PUT(교체), DELETE(삭제)
- 그 외 HEAD, OPTIONS, TRACE 등이 있다.

### 1.4.2 상태 코드

- 요청 처리 결과를 세 자리 숫자로 알려준다.
- 2xx: 성공 / 3xx: 리다이렉션 / 4xx: 클라이언트 오류 / 5xx: 서버 오류
- 숫자가 핵심이고, 함께 오는 사유 구절은 사람을 위한 설명이다.

### 1.4.3 웹페이지는 여러 객체로 이루어질 수 있다

- HTML 파일 하나로 끝나지 않는다.
- CSS, JS, 이미지, 폰트 등 부가 리소스를 가져오기 위해 추가 요청이 발생한다.
- 즉, 웹페이지는 리소스의 집합이다.

---

## 1.5 메시지

<img width="500" height="200" alt="img_2" src="https://github.com/user-attachments/assets/55c802af-04a5-432e-bc52-c8aa1b4d4d2c" />

- HTTP 메시지는 단순한 텍스트 형태라 읽기 쉽다.
- 시작줄, 헤더, 본문 세 부분으로 나뉜다.
- 헤더와 본문 사이는 빈 줄로 구분한다.

구성:
- **시작줄**: 요청이면 무엇을 할지, 응답이면 무슨 일이 일어났는지
- **헤더**: `이름: 값` 형태의 부가 정보
- **본문**: 실제 데이터 (없을 수도 있음)

---

## 1.6 TCP 커넥션

- HTTP는 TCP 위에서 동작한다.
- TCP가 오류 없는 전송과 순서 보장을 책임진다.

> 💡 **HTTP 통신 vs 소켓 통신 개념 정리:**
> - **소켓**: 네트워크 통신을 위한 OS 인터페이스 (프로토콜이 아님)
> - Unix에서 소켓은 파일 디스크립터로 취급됨 → read/write로 데이터 송수신
> - HTTP도 내부적으로 소켓을 사용함
> - "소켓 통신"이라 하면 보통 HTTP 없이 TCP/UDP를 직접 다루는 방식을 의미
> - 정확한 비교: "HTTP 기반 통신" vs "TCP/UDP 직접 통신 (raw socket)"

### 1.6.1 TCP/IP

- HTTP는 애플리케이션 계층 프로토콜이다.
- 네트워크의 복잡한 부분은 TCP/IP에 위임한다.
- 일단 TCP 연결이 수립되면 메시지가 유실되거나 순서가 뒤바뀌는 일이 없다.

> 💡 **TCP가 보장하는 것:**
> - 오류 없는 데이터 전송
> - 순서대로 전달 (보낸 순서 = 받는 순서)
> - 조각나지 않는 데이터 스트림

> 💡 **HTTP 네트워크 프로토콜 스택:**
> ```
> 애플리케이션 계층  ← HTTP
> 전송 계층         ← TCP
> 네트워크 계층      ← IP
> 데이터 링크 계층
> 물리 계층
> ```

> 💡 **전송 단위:**
> - TCP는 세그먼트 단위로 전송
> - IP는 패킷 단위로 전송
>
> 각 계층에서 캡슐화/역캡슐화가 일어나며, IP는 전달만 담당하고 TCP가 신뢰성을 보장한다.

> 💡 **MTU와 MSS:**
> - **MTU**(Maximum Transmission Unit): 네트워크에서 보낼 수 있는 최대 패킷 크기 (이더넷 기준 1500바이트)
> - **MSS**(Maximum Segment Size): TCP 페이로드 최대 크기 (MTU - IP헤더 - TCP헤더 ≈ 1460바이트)
>
> HTTP 요청이 MSS를 넘으면 내부적으로 여러 TCP 세그먼트로 분할되어 전송된다.

### 1.6.2 접속, IP 주소 그리고 포트번호

- 클라이언트는 IP 주소와 포트 번호로 서버에 연결한다.
- 포트를 생략하면 HTTP는 기본적으로 80번을 쓴다.
- DNS가 호스트명을 IP 주소로 변환해준다.

### 1.6.3 텔넷(Telnet)을 이용한 실제 예제

- HTTP가 텍스트 기반이라 텔넷으로 직접 요청을 보내볼 수 있다.
- 이 방법으로 메시지 구조를 직접 확인할 수 있다.

---

## 1.7 프로토콜 버전

- HTTP/0.9: 아주 단순한 초기 버전
- HTTP/1.0: 헤더, 상태 코드 도입
- HTTP/1.1: 성능과 구조 개선, 현재 널리 쓰이는 표준
- HTTP/2: 성능 최적화를 목표로 설계

> 💡 **HOL(Head-of-Line) Blocking**: keep-alive로 커넥션을 재사용해도, 앞선 요청이 느리면 뒤따르는 요청까지 지연되는 현상

> 💡 **HTTP/1.1의 한계:**
> - HOL Blocking 발생
> - 헤더 중복으로 인한 비효율

> 💡 **HTTP/2의 개선:**
> - 텍스트 대신 **바이너리 프레임** 사용
> - 하나의 커넥션으로 여러 요청/응답을 동시에 처리하는 **멀티플렉싱** 지원

> 💡 **HTTP/3:**
> - TCP 레벨의 HOL Blocking과 핸드셰이크 지연을 해결하기 위해 등장
> - UDP 기반의 **QUIC 프로토콜** 사용
> - 대부분의 브라우저는 이미 지원하지만, 서버는 별도 설정이 필요

---

## 1.8 웹의 구성 요소

클라이언트와 서버 사이에는 여러 중간 구성 요소가 존재할 수 있다.

### 1.8.1 프락시

<img width="500" height="300" alt="img" src="https://github.com/user-attachments/assets/487614b8-2cee-4e49-bb0e-7e9aac07e731" />

- 클라이언트와 서버 사이에서 요청/응답을 중계한다.
- 보안, 필터링, 성능 향상 등의 목적으로 활용된다.

### 1.8.2 캐시

<img width="500" height="300" alt="img_4" src="https://github.com/user-attachments/assets/1ee75f9b-8013-4771-b323-65c1cf23843d" />

- 자주 사용되는 리소스를 가까운 곳에 저장해둔다.
- 응답 속도를 높이고 네트워크 부하를 줄인다.

### 1.8.3 게이트웨이

<img width="500" height="300" alt="img_5" src="https://github.com/user-attachments/assets/248a530b-6fd6-4a0d-872b-b4dfa73365a6" />

- 서로 다른 프로토콜 간 변환을 담당한다 (예: HTTP ↔ FTP).
- 클라이언트 입장에서는 일반 서버처럼 보인다.

### 1.8.4 터널

<img width="500" height="300" alt="img_6" src="https://github.com/user-attachments/assets/1d9d111a-f59b-460f-9450-ced08c9b97ff" />

- 데이터를 들여다보지 않고 그대로 전달한다.
- 주로 SSL/TLS 트래픽 전달에 쓰인다.

> 💡 **터널의 동작 원리**: HTTP 프락시를 통해 연결을 열고, 그 연결을 파이프처럼 사용하여 암호화된 TLS 트래픽을 흘려보낸다. 겉보기에는 HTTP 연결이라 방화벽을 통과하지만, 실제로는 다른 암호화 통신이 오갈 수 있다.

### 1.8.5 에이전트

- 사용자 대신 HTTP 요청을 만드는 클라이언트다.
- 웹브라우저가 대표적이고, 검색 엔진 크롤러도 에이전트의 일종이다.

---
